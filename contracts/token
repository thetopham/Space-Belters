// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

interface IERC20Burnable is IERC20 {
    function burn(uint256 amount) external;
}


contract token is ERC20, ReentrancyGuard  {
    using SafeMath for uint256;

    uint256 private constant INITIAL_SUPPLY = 328000000 * (10**18); // 328 million tokens with 18 decimal places
    address public owner;
    mapping(address => bool) private exemptAddresses; // Define a mapping to store exempt addresses

    bool public mintingEnabled;
    
    uint256 public mintMultiplier = 771 ;
    uint256 public singleTokenValue = address(this).balance.mul(1e18).div(totalSupply());


    modifier onlyOwner {
        require(msg.sender == owner, "Caller is not the owner");
        _;
    }

    constructor() ERC20("Token", "Token") payable {
        owner = msg.sender;
        mintingEnabled = false;        
        _mint(msg.sender, INITIAL_SUPPLY);        
        
    }

    receive() external payable {
    if (msg.sender != owner && !exemptAddresses[msg.sender]) {
        contribute();
    }
      }

    function burn(uint256 tokenAmount) external {
    require(tokenAmount > 0, "Token amount must be greater than 0");
    require(balanceOf(msg.sender) >= tokenAmount, "Insufficient token balance");    
    _burn(msg.sender, tokenAmount);
}


     function contribute() public payable nonReentrant {
        require(mintingEnabled, "Minting is currently disabled");
        require(msg.value > 0, "ETH amount must be greater than 0");
      
        // Calculate the number of tokens the user should receive based on a multiple of the price of a single token
        uint256 mintPrice = singleTokenValue * mintMultiplier ;
        // Calculate the number of tokens the user should receive based on the minting price
        uint256 tokenAmount = msg.value.div(mintPrice);
        // Mint the calculated number of tokens to the sender
        _mint(msg.sender, tokenAmount);
     }


     function RedeemTokens(uint256 tokenAmount) external nonReentrant {    
    require(tokenAmount > 0, "Token amount must be greater than 0");
    require(balanceOf(msg.sender) >= tokenAmount, "Insufficient token balance");
    
    // Calculate the ETH amount the user should receive
    uint256 ethAmount = tokenAmount.mul(singleTokenValue).div(1e18);

    _burn(msg.sender, tokenAmount);

    (bool success, ) = msg.sender.call{value: ethAmount}("");
    require(success, "Failed to send ETH");
     }
    

     function setmintMultiplier(uint256 _mintMultiplier) external onlyOwner {
        mintMultiplier = _mintMultiplier;

     }     


    function setMintingEnabled(bool _mintingEnabled) external onlyOwner {
        mintingEnabled = _mintingEnabled;
     }


    function setExemptAddress(address _address, bool _exempt) external onlyOwner {
        exemptAddresses[_address] = _exempt;
    }
 
}
